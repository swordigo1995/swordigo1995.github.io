{"meta":{"title":"swordigo","subtitle":"嗨呀 我还能说什么= =","description":null,"author":"Ren Haocheng","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2016-11-12T07:36:18.000Z","updated":"2016-11-12T08:43:48.580Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2016-11-12T08:45:24.787Z","updated":"2016-11-12T08:45:24.787Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CommingBack","slug":"CommingBack","date":"2017-05-01T20:30:13.000Z","updated":"2017-05-01T20:39:10.411Z","comments":true,"path":"2017/05/02/CommingBack/","link":"","permalink":"http://yoursite.com/2017/05/02/CommingBack/","excerpt":"","text":"Comming back to my HEXO again!Hope it stay alive!","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]},{"title":"","slug":"2017-4-8-RTR","date":"2017-04-08T12:54:52.237Z","updated":"2017-04-09T02:39:35.528Z","comments":true,"path":"2017/04/08/2017-4-8-RTR/","link":"","permalink":"http://yoursite.com/2017/04/08/2017-4-8-RTR/","excerpt":"","text":"RTR-2017.4.85.6.2 Screen-based antialiasing What is Screen-Base method? They operate only on the output samples of the pipeline without any knowledge of the objects being rendered. let’s see something with MSAAsampling various types of data at differing frequencies.They can share some computations around samples. a.k.a CSAA. Fragment is shaded only once! separating coverage from shading and depth storage.Carpenter’s A-buffer","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"zuile","date":"2017-04-07T12:49:04.226Z","updated":"2017-04-07T12:49:37.862Z","comments":true,"path":"2017/04/07/zuile/","link":"","permalink":"http://yoursite.com/2017/04/07/zuile/","excerpt":"","text":"2017.4.7上午： 搞了下SSLspeedy2下chrome登陆的问题。 下午： 本来想找那个协方差矩阵的求法。 看了回paper原文。 看到了performance测试，感觉glslc有点意思。。 看glslc。。体验了一把。但是不能查看number of instruction. 发现需要zbStudio的支持 晚上： 看了下atom编辑器和酷炫插件。。 看了下switch游戏机。。 关注下游戏资讯。。 看了下lua。。。 和zbStudio的tutorial 然而glsl插件还是没装进去","categories":[],"tags":[],"keywords":[]},{"title":"随笔NO.2","slug":"2016-12-11-no-2","date":"2016-12-11T03:52:38.538Z","updated":"2016-12-11T04:07:43.019Z","comments":true,"path":"2016/12/11/2016-12-11-no-2/","link":"","permalink":"http://yoursite.com/2016/12/11/2016-12-11-no-2/","excerpt":"","text":"优班结束，start a new life好久没有更新博客了。12月9号晚上。搞了两个月之久的优班终于结束了。。。本以为从三句半突然变换方式很不好，没想到效果还不错。。三年前谁又能知道我们班可以获得邦清班呢？ 昨天和大志去看了下机场大巴的地方，逛了下春熙路…订了12月21的机票。接下来就看看英语吧。 毕设做的是 physically based rendering :)正是我想要的研究方向~ 对了，昨天在党员的指导下，第一次复原了三阶魔方！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"},{"name":"任务","slug":"任务","permalink":"http://yoursite.com/tags/任务/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]},{"title":"C++内存管理","slug":"2016-11-27-c","date":"2016-11-27T03:46:51.504Z","updated":"2016-11-27T03:46:51.620Z","comments":true,"path":"2016/11/27/2016-11-27-c/","link":"","permalink":"http://yoursite.com/2016/11/27/2016-11-27-c/","excerpt":"","text":"转http://blog.csdn.net/masterft/article/details/1711706 C++内存管理(整理笔记)C++内存管理详解l 内存分配方式 在C++中,内存分成5个区,分别是堆、栈、自由存储区、全局/静态区和常量存储区. 栈:存放函数参数以及局部变量,在出作用域时,将自动被释放.栈内存分配运算内置于处理器的指令集中,效率很高,但分配的内存容量有限. 堆:new分配的内存块(包括数组,类实例等),需delete手动释放.如果未释放,在整个程序结束后,OS会帮你回收掉. 自由存储区:malloc分配的内存块,需free手动释放.它和堆有些相似. 全局/静态区:全局变量(global)和静态变量(static)存于此处.(在以前的C语言中,全局变量又分为初始化的和未初始化的,C++不分) 常量存储区:常量(const)存于此处,此存储区不可修改.l 堆与栈的区别void f(){int *p = new int[5]; }上面一段代码就包含了堆与栈.指针P被分配在了栈中,而new出来的东西则被分配在了堆中,此句可以解释为”在栈中存放了一个指向堆内存的指针p”.(可否理解为:指针p的值是堆内存块的首地址??????)主要区别: 管理方式不同: 栈是编译器自动管理的,堆需手动释放空间大小不同: 在32位OS下,堆内存可达到4GB的的空间,而栈就小得可怜.(VC6中,栈默认大小是1M,当然,你可以修改它)能否产生碎片不同:对于栈来说,进栈/出栈都有着严格的顺序(先进后出),不会产生碎片;而堆频繁的new/delete,会造成内存空间的不连续,容易产生碎片.生长方向不同:栈向下生长,以降序分配内存地址;堆向上生长,以升序分配内在地址.分配方式不同:堆动态分配,无静态分配;栈分为静态分配和动态分配,比如局部变量的分配,就是动态分配(alloca函数),函数参数的分配就是动态分配(我想的…).分配效率不同:栈是系统提供的数据结构,计算机会在底层对栈提供支持,进栈/出栈都有专门的指令,这就决定了栈的效率比较高.堆则不然,它由C/C++函数库提供,机制复杂,堆的效率要比栈低得多.可以看出,栈的效率要比堆高很多,所以,推荐大家尽量用栈.不过,虽然栈有如此多的好处,但远没有堆使用灵活.l 控制C++的内存分配其实C++的内存管理容易而且安全,因为当一个对象消除时,它的析构函数能够安全的释放所有分配的内存.在嵌入式系统中,内存的分配是一个常见问题,保守的使用内存分配是嵌入式环境中的第一原则.当你需使用new/delete时,一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象(??????).对每个类重载new和delete就提供了这样的控制.class TestClass{void *operator new(size_t size); void operator delete(void *p); };void *TestClass::operator new(size_t size){void *p = malloc(size); return p; }void TestClass::operator delete(void *p){free(p); }而对象数组的分配又不同于单个对象的分配,所以你仍需再重载new[]和delete[]操作符.但值得注意的是,对于C++而言,分配对象数组的大小等于数组参数的大小再加上额外的对象数目的一些字节,所以要尽量避免使用对象数组.class TestClass{void *operator new[](size_t size); void operator delete[](void *p); };void *TestClass::operator new{void *p = malloc(size); return p; }void TestClass::operator delete{free(p); }void main(){TestClass *p = new TestClass[10]; delete[] p; }l 常见的内存错误及对策² 内存分配未成功,却使用了它解决办法:在使用之前检查指针是否为NULL,如果指针p是函数参数,那么在函数入口处assert(p!=NULL).如果是用malloc或new申请的话,应该用if(p==NULL)进行防错处理.² 内存分配成功,但未初始化就使用它 解决办法:不要嫌麻烦,记得初始化就行了.² 内存分配成功且已初始化,但操作越过了边界 解决办法:此问题通常出现于循环之中,注意不要多1或少1就行.² 忘记释放内存 解决办法:含有这个错误的函数每调用一次就丢失一块内存,造成内存耗尽.记得free或delete就行.² 释放了内存却继续使用它有三种情况:※程序中对象的关系过于复杂,难以搞清哪个对象是否已经释放了内存.※函数中return写错,返回了指向栈中的指针或引用.※ free或delete后,没有将指针设为NULL,产生”野指针”.l 指针与数组C++中,指针和数组有着不少相似的地方,容易让我产生错觉,以为它们是等价的,其实不然.数组在静态存储区或是栈上被创建,数组名对应着(而不是指向)一块内存,其地址与容量在生命周期内保持 不变.而指针可以随时指向任意类型的内存块,远比数组灵活,但也危险. char a[] = &quot;hello&quot;; a[0] = ‘x’;char *p = “world”;p[0] = ‘y’; //试图修改常量字符串,编译器不能发现,执行会报错杜绝”野指针”“野指针”不是NULL指针,是指向”垃圾内存”的指针.它的缺省值是随机的,所以它会乱指一气.产生”野指针”的原因有3种:1、指针变量没有被初始化;2、指针被free/delete后被没有设置为NULL;3、指针操作超越了变量的作用域范围.如下例,p-&gt;fun()时,a已经消失.class A{public:void fun() {} };void Test(){A *p; { A a; p = &amp;a; //a的生命周期会在出作用域时结束 } p-&gt;fun(); //p此时是&quot;野指针&quot; }l malloc/free 和new/delete有了malloc/free为何还需要new/delete呢? malloc/free是标准库函数,而new/delete是运算符,它们都可用于申请/释放动态内存.但对于非基本数据类型(比如类对象)而言, malloc/free无法自动执行对象的构造/析构函数.而new/delete却可以.malloc 函数malloc的原型:void *malloc(size_t size);函数malloc的使用: int *p = (int*)malloc(sizeof(int)*length);//length前是乘号 可见,在使用malloc时需要进行类型转换.而使用sizeof运算符也是良好的代码风格. new new内置了sizeof,所以用起来写法更简洁.注意,使用new创建对象数组时,只能使用对象的无参数构造函数.如 Obj o = new Obj[100];l 内存耗尽怎么办?解决办法:1、判断指针是否为NULL,如果是立即返回void fun(){ A a = new A(); if(a==NULL)return; }2、判断指针是否为NULL,如果是立即终止void fun(){ A *a = new A(); if(a==NULL)exit(1); }提示:不要不忍心使用exit(1),否则会害死OS.所以推荐使用方法2.不过搞笑的是,在32位OS上,永远也不会内存耗尽.","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"programming languages","slug":"programming-languages","permalink":"http://yoursite.com/tags/programming-languages/"}],"keywords":[]},{"title":"PAT 1002. A+B for Polynomials","slug":"2016-11-18-pat-1002-ab-for-polynomials","date":"2016-11-18T13:05:01.224Z","updated":"2016-11-18T13:05:01.304Z","comments":true,"path":"2016/11/18/2016-11-18-pat-1002-ab-for-polynomials/","link":"","permalink":"http://yoursite.com/2016/11/18/2016-11-18-pat-1002-ab-for-polynomials/","excerpt":"","text":"https://www.patest.cn/contests/pat-a-practise/1002 solution 1.link list 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;using namespace std;typedef struct _PolynomialNode&#123; int exponent; double coefficient; struct _PolynomialNode* next;&#125; PolynomialNode;typedef PolynomialNode* Polynomial;void printPolynomial(Polynomial p)&#123; Polynomial temp = p-&gt;next; int len = 0; for (; temp; temp = temp-&gt;next) len++; printf(\"%d\", len); temp = p-&gt;next; while (temp) &#123; printf(\" %d %.1f\", temp-&gt;exponent, temp-&gt;coefficient); temp = temp-&gt;next; &#125;&#125;void readPolynomial(Polynomial rear)&#123; int k; int e; double c; cin &gt;&gt; k; while (k--) &#123; cin &gt;&gt; e &gt;&gt; c; PolynomialNode* node = (Polynomial)malloc(sizeof(PolynomialNode)); node-&gt;exponent = e; node-&gt;coefficient = c; node-&gt;next = NULL; rear-&gt;next = node; //add a new node in the rear rear = rear-&gt;next;// rear go on &#125;&#125;void attach(int e, double c, Polynomial* pRear)//使用pRear才能返回rear指针&#123; PolynomialNode* node = (Polynomial)malloc(sizeof(PolynomialNode)); node-&gt;coefficient = c; node-&gt;exponent = e; node-&gt;next = NULL; (*pRear)-&gt;next = node; *pRear = node;&#125;int compare(int e1, int e2)&#123; if (e1 &gt; e2) return 1; else if (e1 &lt; e2) return -1; else return 0;&#125;int main()&#123; Polynomial p1, p2; Polynomial front, rear, temp;// result p1 = (Polynomial)malloc(sizeof(PolynomialNode));//空 头结点 p2 = (Polynomial)malloc(sizeof(PolynomialNode)); rear = (Polynomial)malloc(sizeof(PolynomialNode)); front = rear; readPolynomial(p1); readPolynomial(p2); p1 = p1-&gt;next; p2 = p2-&gt;next; double sum; while (p1&amp;&amp;p2) // one is not zero &#123; switch (compare(p1-&gt;exponent,p2-&gt;exponent)) &#123; case 1: attach(p1-&gt;exponent, p1-&gt;coefficient, &amp;rear); p1 = p1-&gt;next; break; case -1: attach(p2-&gt;exponent, p2-&gt;coefficient, &amp;rear); p2 = p2-&gt;next; break; case 0: sum = p1-&gt;coefficient + p2-&gt;coefficient; if(sum) attach(p1-&gt;exponent, sum, &amp;rear); p1 = p1-&gt;next; p2 = p2-&gt;next; break; default: break; &#125; &#125;// then copy the last nodes into another one for (; p1; p1 = p1-&gt;next) attach(p1-&gt;exponent, p1-&gt;coefficient, &amp;rear); for (; p2; p2 = p2-&gt;next) attach(p2-&gt;exponent, p2-&gt;coefficient, &amp;rear); //rear-&gt;next = NULL; //temp = front; //front = front-&gt;next; //free(temp); printPolynomial(front); return 0;&#125; flexible but difficult to realize solution 2array 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;double sum[1002] = &#123;&#125;;int main()&#123; double c; int k, e; int counter = 0; int max_index; //memset(sum, 0, sizeof(int)); scanf(\"%d\", &amp;k); max_index = 0; while (k--) &#123; scanf(\"%d %lf\", &amp;e, &amp;c); sum[e] += c; if (e &gt; max_index) max_index = e; &#125; scanf(\"%d\", &amp;k); while (k--) &#123; scanf(\"%d %lf\", &amp;e, &amp;c); sum[e] += c; if (e &gt; max_index) max_index = e; &#125; for (int i = max_index; i &gt;= 0; i--) if (sum[i]) counter++; printf(\"%d\", counter); for (int i = max_index; i &gt;= 0; i--) if (sum[i]) printf(\" %d %.1lf\", i, sum[i]); return 0;&#125; easy to realize.more suitable for quick test. Usage of “ memset “1234char buffer[] = \"Helloworld\\n\";printf(\"Buffer before memset:%s\\n\", buffer);memset(buffer, '*', strlen(buffer));printf(\"Buffer after memset:%s\\n\", buffer); memset函数对数组而言只能用于置零（0）或置负一（-1）操作. memset(void s, int ch,size_tn);中key实际范围应该在0~~255，因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节，比如int a[5]赋值memset（a,-1,sizeof(int )5）与memset（a,511,sizeof(int )*5） 所赋值的结果是一样的都为-1. 不用过度使用memset memset可以方便的清空一个结构类型的变量或数组。sizeof(struct_sample)*n","categories":[{"name":"PAT(Advanced Level)","slug":"PAT-Advanced-Level","permalink":"http://yoursite.com/categories/PAT-Advanced-Level/"}],"tags":[{"name":"online judge","slug":"online-judge","permalink":"http://yoursite.com/tags/online-judge/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}],"keywords":[{"name":"PAT(Advanced Level)","slug":"PAT-Advanced-Level","permalink":"http://yoursite.com/categories/PAT-Advanced-Level/"}]},{"title":"listening comprehension","slug":"2016-11-16-listening-comprehension","date":"2016-11-16T15:34:43.740Z","updated":"2016-11-16T15:34:44.174Z","comments":true,"path":"2016/11/16/2016-11-16-listening-comprehension/","link":"","permalink":"http://yoursite.com/2016/11/16/2016-11-16-listening-comprehension/","excerpt":"","text":"What a wonderful performance your rock band has never sounded better! Many thanks! I guess aloughts our (all those hours of ) practice in the past month finally paid (paying) off. Q: what does the man mean? 2. I can’t decide what to do for my summer vacation. I either want to go on a bike tour of European or go diving (潜水) in Mexico. Well. we are offering an all-inclusive(全套服务) two week trip to Mexico for only 300 dollars. Q: what does the women suggest the man do for his vacation? 3. How long do you think this project might take? I had said(‘d say) about three mouth but it could take longer if something unexpected happened. May be *(we’d better allow an extra month) at * on best month, we won’t have to worry about being late. Q: Why does the man said extra time should be allowed exper mouth are needed for the project? 4. I’m thinking about becoming a member here. I’d like some information. Sure. a three mouth membership costs cause 150 dollars. And that include … use of the wait room for ..room? sauna and pool. I will give you a free pass so that you can try that the ficility facilities before you decide. Q: What do we learn from the conversation? I’m sorry to hear*feild? that you failed the physics test*course,Ted ? Let’s face it.That’s …. I am just not cut out to be a scientist. Q: what does the man mean? 6. Gary insisted on *garign …* or buying the food for the picnic? That’s pretty generousgenerous of him? but shouldn’t we at least offer gear a offer to share shooten the expenses? He has a big family to support. Q: what does the women suggest they do? 7. Did you see the headlines in the paper this morning? yeah. Apparently(表面上看起来,显然) .. the bus company will be laying off has made ban off their employee since they can’t go on in agreement on wages(工资,不太固定的工资) edges by midnight. Q: what did the man read about? 8. have we receirvedsee a payment for the overseas order we delivered since we … over last month? yes. the cheak came in yesterday afternoon. I would be dispositing it when it goes to bank today.","categories":[],"tags":[],"keywords":[]},{"title":"Probability and Hashing PART 1","slug":"2016-11-16-probability-and-hashing-part-1","date":"2016-11-16T07:56:01.907Z","updated":"2016-11-19T03:59:27.297Z","comments":true,"path":"2016/11/16/2016-11-16-probability-and-hashing-part-1/","link":"","permalink":"http://yoursite.com/2016/11/16/2016-11-16-probability-and-hashing-part-1/","excerpt":"","text":"Rolling a die(骰子)Sampling and Monte Carlo SimulationsThe Copenhagen DoctrineThe behavior of the physical world cannot be predicted. Nondeterminism causal nondeterminism (因果不确定性)Not every event is caused by previous events predictive nondeterminism(预测不确定性)Lack of knowledge about the world makes it impossible makeaccurate predications about future states原理上无法预测？没有足够的信息而无法预测？ Stochastic ProcessesAn ongoing process where the next state might depend on both the previous states and some random element. some English notesWe looked at things quite informally (非正式地) before. lay down some of the foundations we need to understand stochastic situations more rigorously(严密地,严厉地). parabolic path(抛物线轨迹)The physical world is a completely predicable place.","categories":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"MOOC","slug":"MOOC","permalink":"http://yoursite.com/tags/MOOC/"}],"keywords":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}]},{"title":"PAT 1001. A+B Format","slug":"2016-11-16-pat-1001-ab-format","date":"2016-11-16T03:25:28.442Z","updated":"2016-11-16T03:29:51.322Z","comments":true,"path":"2016/11/16/2016-11-16-pat-1001-ab-format/","link":"","permalink":"http://yoursite.com/2016/11/16/2016-11-16-pat-1001-ab-format/","excerpt":"","text":"1001. A+B Formathttps://www.patest.cn/contests/pat-a-practise/1001 my codes-1000000 &lt;= a, b &lt;= 1000000.in 32bit machine, unsigned int 0～4294967295 , int -2147483648～2147483647 .So, it’s not necessary to use high precision algorithm or long long/ _int64. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;iomanip&gt; //使用流操纵算子#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; freopen(\"in.txt\", \"r\", stdin); freopen(\"out.txt\", \"w\", stdout); int a, b, c; cin &gt;&gt; a &gt;&gt; b; c = a + b; cout.fill('0'); if (c / 1000000 != 0) cout &lt;&lt; c / 1000000 &lt;&lt; ',' &lt;&lt; setw(3) &lt;&lt; abs((c % 1000000) / 1000) &lt;&lt; ',' &lt;&lt; setw(3) &lt;&lt; abs(c % 1000); else if (c / 1000 != 0) cout &lt;&lt; c / 1000 &lt;&lt; ',' &lt;&lt; setw(3) &lt;&lt; abs(c % 1000); else cout &lt;&lt; c; return 0;&#125; warning: Don’t forget to fill “zero” after modulo operation. properties of positive and negative. This method only works under given precision. other solutions1. with universality 计算a+b的结果c，处理掉负号；按c按1000进制将结果存储在数组中；输出最高位；剩下的每位：输出一个 “,” 号，再输出该位（补零） 12345678#include &lt;cstdio&gt;int a,b,l,ans[10];int main( )&#123; for (scanf(\"%d%d\",&amp;a,&amp;b); a+b&lt;0; printf(\"-\")) a=-a,b=-b; for (a+=b,l=a==0; a; a/=1000) ans[++l]=a%1000; for (printf(\"%d\",ans[l]); --l; ) printf(\",%03d\",ans[l]);&#125; a cool code with less readability. 2. recursion 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;void fun(int c)&#123; if(c/1000) &#123; fun(c/1000); printf(\",%03d\",c%1000); &#125; else printf(\"%d\",c);&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int sum = a + b; if(sum &lt; 0) &#123; cout&lt;&lt;\"-\"; sum = -sum; &#125; fun(sum); cout&lt;&lt;endl; return 0;&#125; simple and a clear logic structure %3d–可以指定宽度，不足的左边补空格%-3d–左对齐,右边补空格%03d—一种左边补0的等宽格式,比如数字12,%03d出来就是: 012","categories":[{"name":"PAT(Advanced Level)","slug":"PAT-Advanced-Level","permalink":"http://yoursite.com/categories/PAT-Advanced-Level/"}],"tags":[{"name":"online judge","slug":"online-judge","permalink":"http://yoursite.com/tags/online-judge/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}],"keywords":[{"name":"PAT(Advanced Level)","slug":"PAT-Advanced-Level","permalink":"http://yoursite.com/categories/PAT-Advanced-Level/"}]},{"title":"Random Walks and Simulation Models PART 3","slug":"no-4-random-walks-and-simulation-models-part-3","date":"2016-11-15T10:46:33.187Z","updated":"2016-11-15T10:51:38.768Z","comments":true,"path":"2016/11/15/no-4-random-walks-and-simulation-models-part-3/","link":"","permalink":"http://yoursite.com/2016/11/15/no-4-random-walks-and-simulation-models-part-3/","excerpt":"","text":"Running Python Codesan importable module is not a script in python. The code provided in the courses website is a module. We can say the code without main function. So, it is necessary to import the model and run the function in ti. We can also executing modules as scripts.using123if __name__ == \"__main__\": import sys fib(int(sys.argv[1])) We can run a Python module like this: python fibo.py There is a trick to run .py file under Python shell import os 载入os模块os.chdir(“X:\\XXX\\YYY…”) 添加你的文件夹路径 注意用路径两侧有引号execfile(“XXX.py”) 在这个路径中打开你的py文件 from fibo import * we can use function name to access directly. python documentation 6.Modules","categories":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"MOOC","slug":"MOOC","permalink":"http://yoursite.com/tags/MOOC/"}],"keywords":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}]},{"title":"Random Walks and Simulation Models PART 2","slug":"no-3-random-walks-and-simulation-models-part-2","date":"2016-11-14T16:57:54.757Z","updated":"2016-11-14T17:05:12.783Z","comments":true,"path":"2016/11/15/no-3-random-walks-and-simulation-models-part-2/","link":"","permalink":"http://yoursite.com/2016/11/15/no-3-random-walks-and-simulation-models-part-2/","excerpt":"","text":"Brownian MotionIn 1827, the Scottish botanist(植物学家) Robert Brown observed that pollen (花粉)particles suspended in water seemed to float around at random.made no attempts to model it mathematically. Brownian motion is example of something that has come to be called a random walk. Drunken WalkerDescriptionA question comes. A drunken(酒醉的) farmer standing in the middle of the field.And every second he takes one step in a random direction.Now I want you to ponder(思索) the question, what is the expected distance from theorigin in, say 1,000 seconds. Classes Location two dimensions. No built-in assumption about direction. Field many drunks drunks can be at same location. field unbounded Drunk 123456789101112class Drunk(object): def __init__(self, name): self.name = name def __str__(self): return 'This drunk is named ' + self.nameimport randomclass UsualDrunk(Drunk): def takeStep(self): stepChoices =\\ [(0.0,1.0),(0.0,-1.0),(1.0, 0.0),(-1.0, 0.0)] return random.choice(stepChoices)","categories":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"MOOC","slug":"MOOC","permalink":"http://yoursite.com/tags/MOOC/"}],"keywords":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}]},{"title":"Random Walks and Simulation Models PART 1","slug":"no-2-random-walks-and-simulation-models","date":"2016-11-14T04:10:50.990Z","updated":"2016-11-14T16:15:21.103Z","comments":true,"path":"2016/11/14/no-2-random-walks-and-simulation-models/","link":"","permalink":"http://yoursite.com/2016/11/14/no-2-random-walks-and-simulation-models/","excerpt":"","text":"Simulation Modelsan experimental device called model. simulation models are descriptive(描述性的), not prescriptive（规定性的）. Kinds of simulation modelDeterministic(确定性模型) vs Stochastic(随机性模型)Static vs DynamicDiscrete vs Continuous Deterministic simulations are completely defined by the modelRerunning the simulation will not change the result how a system works under given conditions, but not how to arrange the conditions to make the system work best.Deterministic simulations are typically used when the system being modeled is too complex to analyze analytically(用解析方法). Stochastic simulations include randomnessDifferent runs can generate different results In a discrete model, values of variables are enumerable (e.g.,integers).In a continuous model, they are not enumerable(e.g., real numbers). Most prominently(最显著的是)systems that were not mathematically tractable(听话,驯服的) (social science e.g., economics) conventional mathematics（传统数学）doesn’t works.USE successive refinements – how to change the model to make the results more accurate. pervasiveness(无处不在) of simulationsinevitably(不可避免地) somebody says, physics. To recapitulate(回顾 一下要点), simulation attempts to build an experimental device called model.The goal of the model is to provide useful information about the possible behaviors of the system being modeled.Approximate of reality All models are wrong, but some are useful.","categories":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"MOOC","slug":"MOOC","permalink":"http://yoursite.com/tags/MOOC/"}],"keywords":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}]},{"title":"NO.1 Introduction to Computation","slug":"no-1-introduction-to-computation","date":"2016-11-12T04:21:32.419Z","updated":"2016-11-13T02:51:17.939Z","comments":true,"path":"2016/11/12/no-1-introduction-to-computation/","link":"","permalink":"http://yoursite.com/2016/11/12/no-1-introduction-to-computation/","excerpt":"","text":"Fundamentation of computer Performs calculations (speed) Remember the results (storage) Though the speed is fast and the storage is large, there are some limitations. too complex impossible to compute( a classic problem is how to predict whether a piece of code will always halt with and answer for any input.) Fast simple calculations is always not enough for solving problems. A good algorithm design is needed. Computational problem solvingknowledge? Declarative knowledge(陈述性知识） statements of factsome definition in math e.g. square root. Imperative knowledge(命令性知识） how to do . a recipehave specific steps Capture a recipe? how to run program(basic machine architecture) program – sequence of instructions(predefined set of primitive instructions) interpreter – change flow of control Turing complete (图灵完备) we can compute anything using six primitives! Programming language characteristicEach programming language provides a set of primitive operations.provides mechanisms(机制) for combining primitives to form complex expressions.provides mechanisms for deducing(推断) meanings or values. Aspects of languages primitives–numbers,strings,simple operators.etc. syntax(语法)–strings of characters and symbols are well-formed . semantics(语义) static semantics – syntactically valid strings have a meaning.full semantics – meaning associated with a syntactically correct string of symbols with no static semantic errors(always have exactly one meaning in programming languages, ambiguous may happen in nature languages) WRONG Syntactic errors - easily cought Static semantic errors-compiled language chech carefully before running.-interpreted language check while interpreting the program. Full semantic errors - don’t have static semantic error, the meaning is not what we intended.","categories":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}],"tags":[{"name":"study note","slug":"study-note","permalink":"http://yoursite.com/tags/study-note/"},{"name":"MOOC","slug":"MOOC","permalink":"http://yoursite.com/tags/MOOC/"}],"keywords":[{"name":"MIT 6.00 STUDY NOTES","slug":"MIT-6-00-STUDY-NOTES","permalink":"http://yoursite.com/categories/MIT-6-00-STUDY-NOTES/"}]},{"title":"随笔NO.1","slug":"diary-no-1","date":"2016-11-11T11:11:23.517Z","updated":"2016-11-11T16:51:24.637Z","comments":true,"path":"2016/11/11/diary-no-1/","link":"","permalink":"http://yoursite.com/2016/11/11/diary-no-1/","excerpt":"lalala终于搭好了自己的blog","text":"lalala终于搭好了自己的blog 最近任务好多，自己好乱。 Task List： 优班答辩三页纸 MIT大作业 the last two assignments outdoorAR medianCut实现 MIT online Course 6.00.1X 计算机科学和PYTHON编程导论 6.00.2X 计算思维和数据科学导论 Unity 进阶与 shader 英语六级 反正有几个早晚要做的快点搞定吧。优班 MIT 项目 不要忘了英语啊！！！Oh my poor English.今天是双11:joy:最后来个校徽：）","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://yoursite.com/tags/心情/"},{"name":"任务","slug":"任务","permalink":"http://yoursite.com/tags/任务/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}]},{"title":"Hello World","slug":"hello-world","date":"2013-07-13T12:46:25.000Z","updated":"2016-11-11T11:35:53.468Z","comments":true,"path":"2013/07/13/hello-world/","link":"","permalink":"http://yoursite.com/2013/07/13/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}